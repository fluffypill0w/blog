---
layout: "post"
title:  "Ethernaut Full Write-Up"
date:   2021-05-10 10:58:33 +0200
categories: CTF Ethernaut
---

It's been a while since my first post on the [Ethernaut challenge](), but everyone's favorite pillow is back with a 
full walkthrough of each level. Here you can find the [code for all of my exploit contracts](https://github.com/fluffypill0w/ethernaut-solutions/tree/main/contracts), and an [explanation of 
Level 0 here](https://fluffypill0w.github.io/blog/ctf/ethernaut/2021/01/11/Ethernaut-Level-0.html).

## Level 1 - Fallback

This level requires two things: 
    1. Become the owner of your instance.
    2. Drain the balance of the contract. 

When we look at the code, we can see that the owner is set to the address of whoever deployed the contract as part of the <code>constructor</code> function. So how do we become the owner? 

When we look at the <code>contribute</code> function, we see that we can become the owner if our total contributions are more than that of the owner... but we can also see that we are required to send less than 0.001 ether each time we call the function. This means that it would take a very long time and more than 1000 ETH to become the owner in this way, so let's look for another option.

Aha, [the fallback function](https://www.tutorialspoint.com/solidity/solidity_fallback_function.htm)! If we send this contract any amount of ETH while having previously contributed any amount via the <code>contribute</code> method, we become the owner. And once we're the owner, it's a simple task to drain the balance of the contract by calling <code>withdraw</code>. 

This means that we can beat this level by entering the following lines into the browser console one by one, and then finally submitting the instance.

    await contract.contribute({value: 100000000000000})
    await contract.sendTransaction({value: 1000000000000})
    await contract.withdraw()

## Level 2 - Fallout

The goal of this level is to become the owner of the contract. However, unlike the last level, the only function that assigns ownership is the [constructor function](https://www.tutorialspoint.com/solidity/solidity_constructors.htm)... or does it?

If you look closely, you can see that the function name is really 'Fal1out' with a '1' instead of a second letter 'l'. This means that the function is not actually a constructor at all and can be called anytime after contract creation. In order to beat the level, we simply need to make the following function call in our console:

    await contract.Fal1out()

## Level 3 - Coin Flip

To beat this level we need to be able to predict the outcome of the coin flip generated by the contract at least 10 times is a row. Luckily for us, the results of <code>flip</code> are not random but rather based on [some globally available variables and functions](https://docs.soliditylang.org/en/v0.8.0/units-and-global-variables.html#special-variables-and-functions).

We can copy the same logic the contract uses to calculate <code>side</code> and then submit a correct coin flip guess every time. An easy way to do this is to write the contract code in [Remix](https://remix.ethereum.org/) and to [compile and deploy it](https://remix-ide.readthedocs.io/en/latest/create_deploy.html) from there as well.

[See the code.](https://github.com/fluffypill0w/ethernaut-solutions/blob/18d9ce865d3ba2dbfb825e1f0dc6fd475aa57fea/contracts/Level%2003%20-%20AttackCoinFlip.sol)

## Level 4 - Telephone

Once again the goal of the level is to gain ownership of the contract. In order to do this, we need to [understand the difference](https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin) between <code>tx.origin</code> and <code>msg.sender</code>.

In order to successfully call <code>changeOwner</code> and pass our wallet address as the new owner, the function call must originate from a different address than <code>msg.sender</code>. A good way to do this is to deploy a new contract to attack our level instance. 

[See the code.](https://github.com/fluffypill0w/ethernaut-solutions/blob/18d9ce865d3ba2dbfb825e1f0dc6fd475aa57fea/contracts/Level%2004%20-%20AttackTelephone.sol)

## Level 5 - Token

For this level we need to somehow provoke an overflow that will assign us more tokens than are currently in our assigned
balance.

We can see that inside the <code>transfer</code> function there is a subtraction operation:

    require(balances[msg.sender] - _value >= 0);

Given that we currently have 20 tokens, if we pass a value larger than 20 to <code>transfer</code> we'll [cause an overflow](https://medium.com/3-min-blockchain/understanding-uint-overflows-and-underflows-solidity-ethereum-8603339259e6)and the result will be a much larger integer, from which our previous balance of 20 will be subtracted and then the remaining tokens assigned to our address.

Let's pass the instance address and 21 tokens as arguments to  <code>transfer</code> and then check our balance:

    await contract.transfer("YOUR_INSTANCE_ADDRESS", 21)
    await contract.balanceOf("YOUR_PLAYER_ADDRESS")

We now have a ridiculously large balance and are ready to submit our instance.

## Level 6 - Delegation

//TODO

## Level 7 - Force

This level was one of my favorites because of its simplicity. It's basically an empty contract with no payable functions, but we have to get it to shut up and take our money already. But how?

Even contracts that do not have a payable fallback function will be forced to receive ETH from a given address if that
address is [made to self-destruct](https://solidity-by-example.org/hacks/self-destruct/) and designates the target contract's address as the destination for any stored funds.

[See the code.](https://github.com/fluffypill0w/ethernaut-solutions/blob/18d9ce865d3ba2dbfb825e1f0dc6fd475aa57fea/contracts/Level%2007%20-%20AttackForce.sol)

## Level 8 - Vault

We need to find the password and submit it to the <code>unlock</code> function in order to beat this level. 

The <code>password</code> variable has been initialized with the <code>private</code> modifier. However, this does not mean that the variable is, in fact, [a secret](https://docs.soliditylang.org/en/v0.8.4/security-considerations.html?highlight=private%20variables). Anyone can read any smart contract's storage as it is on-chain.

In this case, the password is stored in <code>slot 1</code> (<code>slot 0</code> is occupied by the variable <code>locked</code>). We can read the password from our browser console by calling:

    await web3.eth.getStorageAt("YOUR_INSTANCE_ADDRESS", 1);

We receive <code>"0x412076657279207374726f6e67207365637265742070617373776f7264203a29"</code> which we then need to pass to <code>unlock</code> in order to pass the level when we submit our instance:

    await contract.unlock("0x412076657279207374726f6e67207365637265742070617373776f7264203a29")

## Level 9 - King

The premise is quite simple. Whenever the contract receives more ETH than the current prize, it send the previous king the new prize amount and the sender becomes the new king. 

First, let's check the current prize amount. We can do this by checking the contract's storage like in the previous level. The value of the prize variable is again stored at <code>slot 1</code>.

    await web3.eth.getStorageAt("YOUR_INSTANCE_ADDRESS", 1);

Since the current prize is 1 ether, we need to send slightly more than that to this contract in order to become the king. If we initiate this transaction from a contract with no fallback function, the level will be unable to reclaim kingship as it cannot transfer the prize amount to us.

[See the code.](https://github.com/fluffypill0w/ethernaut-solutions/blob/18d9ce865d3ba2dbfb825e1f0dc6fd475aa57fea/contracts/Level%2009%20-%20AttackKing.sol)

## Level 10 - Re-entrancy

The goal here is to drain this contract of its funds. There's a problem-- we can only withdraw what we've put into the contract via <code>donate</code>, right?

Let's look at the logic of the <code>withdraw</code> function. The contract first checks that the amount we're withdrawing is equal to or less than our balance. Then it sends the funds back to us via our fallback function before finally adjusted our balance to reflect the withdrawal. 

The vulnerability lies in the fact the our fallback function is triggered before our balance is adjusted. We can [re-enter the contract by placing some malicious code in our fallback function](https://quantstamp.com/blog/what-is-a-re-entrancy-attack) that will repeatedly withdraw funds from the contract until the contract's balance is zero.

[See the code.](https://github.com/fluffypill0w/ethernaut-solutions/blob/18d9ce865d3ba2dbfb825e1f0dc6fd475aa57fea/contracts/Level%2010%20-%20AttackReentrancy.sol)

## Level 11 - Elevator

This level was a bit tricky for me. 

Once we call <code>goTo</code> from our attacker contract, our victim will call <code>isLastFloor</code> in our contract to evaluate if the floor number we've pushed to it with <code>goTo</code> first is not the top floor and then subsequently is the top floor. All of this [without us being able to modify the state](https://www.tutorialspoint.com/solidity/solidity_view_functions.htm), since <code>isLastFloor</code> has a <code>view</code> modifier.

I know what you're thinking. What in the world?? @$&%!!! I know, dear reader, because I once was where you are now. But fear not, just because we can't modify the state within the function itself doesn't mean that we can't from outside of it...

I initialized a <code>bool</code> variable called <code>penthouseButton</code> within the <code>constructor</code> function and set it to <code>false</code>. Once we call <code>goTo</code>, the target contract will evaluate whichever floor number we've given it with our <code>isLastFloor</code> function, changing <code>penthouseButton</code> to <code>true</code> and returning <code>false</code>. When the function is called a subsequent time it will then return <code>true</code>.

[See the code.](https://github.com/fluffypill0w/ethernaut-solutions/blob/18d9ce865d3ba2dbfb825e1f0dc6fd475aa57fea/contracts/Level%2011%20-%20AttackElevator.sol)

## Level 12 - Privacy

We need to unlock this contract to beat this level. Looking at the <code>unlock</code> function, we can see that the only two variables we need to worry about are <code>data</code> and <code>locked</code>. We'll need to look into how the <code>data</code> array is stored in order to create the key for the level.

Just like with levels 8 and 9, we can look inside the storage to find the value of <code>data</code>. We need to know about [data storage optimization in Solidity](https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde) in order to know in which slots to look for our value.

Our first variable, <code>locked</code>, is a <code>bool</code> located at <code>slot0</code>. The next declared variable, <code>ID</code>, is a constant and is stored elsewhere. Since the next 3 variables together along with <code>locked</code> have a size of less than 32 bytes, they are also stored all together at <code>slot0</code>. This means that <code>data</code> is located in slots 1-3. Since our target contract tells us we need the information store at <code>data[2]</code>, we know we need to look into <code>slot3</code>:

    await web3.eth.getStorageAt("YOUR_INSTANCE_ADDRESS", 3);

Since this call returns a 32-byte value, we will need to [convert it to 16 bytes]((https://www.tutorialspoint.com/solidity/solidity_conversions.htm)) and pass this new value to the target contract as our key. In this case we can just use the first half of our 32 bytes.

[See the code.](https://github.com/fluffypill0w/ethernaut-solutions/blob/18d9ce865d3ba2dbfb825e1f0dc6fd475aa57fea/contracts/Level%2012%20-%20AttackPrivacy.sol)

## Level 13 - Gatekeeper One 

//TODO

## Level 14 - Gatekeeper Two

//TODO

## Level 15 - Naught Coin 

//TODO

## Level 16 - Preservation

//TODO

## Level 17 - Recovery

//TODO

## Level 18 - MagicNumber

//TODO

## Level 19 - Alien Codex

//TODO

## Level 20 - Denial

//TODO

## Level 21 - Shop

//TODO

## Level 22 - Dex

//TODO